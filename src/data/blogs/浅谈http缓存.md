---
title: 浅谈http缓存
date: 2020-03-01 13:40:21
tags: [计算机网络,随笔]
---

平时使用浏览器上网经常能遇到缓存的情况，很直观的一点就是不久前打开过一个网页，再打开时加载速度就非常快。之前我把游戏部署在服务器上时，第一次加载因为要请求各种资源，速度非常慢；但是第二次再打开很快就加载完成了。这就是由于缓存的存在。

<!--more-->

## 1. 什么是http缓存？

简单来说，缓存可以描述为如下的机制：

- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及相应的缓存标识；
- 浏览器每次拿到请求返回的结果，都会把该结果和相应的缓存标识存放进浏览器的缓存中。

根据如上的规则，我们就知道：浏览器第一次发起http请求时，浏览器的缓存中肯定是没有返回结果的，所以浏览器要做的就是收到请求的结果后将该结果和缓存标识存入缓存中。因此第一次请求的过程可以描述为下图：

![](/img/request1.png)

之后再发起请求的时候就能在浏览器缓存中找到结果和缓存标识，浏览器再根据缓存标识判断是否直接将结果渲染在页面上。这个判断的过程又分为两种：强制缓存和协商缓存。



## 2. 强制缓存

浏览器向服务器发起请求后，服务器会将缓存规则放入http响应报文的的头部中，然后和请求结果一起返回给浏览器。强制缓存简单来说就是浏览器根据响应报文头部中特定字段来判断该结果是否已经过期，如果没有过期就可以直接将结果显示出来。expires和cache-control就是两个表示是否过期的字段。

![](/img/cache-control.png)

如上图所示，cache-control字段指示了在31536000秒内该缓存都不会失效，而expires字段指示了缓存失效的具体时间点。但是由于expires字段中的时间点是由服务器规定的，所以如果服务端与客户端的时区不同，该字段会有一定偏差。因此cache-control字段的优先级高于expires字段。cache-control字段也有其他取值：

- public：所有内容都将被缓存（客户端和代理服务器端都可以缓存）
- private：默认值，所有内容都将被客户端缓存
- no-cache：客户端缓存内容，但是是否使用缓存要通过协商缓存来验证决定
- no-store：不使用缓存
- max-age=xxx：缓存内容在xxx秒后失效



## 3. 协商缓存

协商缓存就是强制缓存过期后，浏览器带着缓存标识向服务器发起请求，服务器根据缓存标识来判断该已过期缓存是否可以继续使用。和强制缓存类似，协商缓存的缓存标识也是放在http头部返回浏览器的。控制协商缓存的字段分别有：last-modified / if-modified-since和etag / if-none-match。

- last-modified / if-modified-since

顾名思义，last-modified指示了最近一次修改的时间。服务器响应请求时，在该字段中返回该资源文件在服务器最后被修改的时间。而if-modified-since字段则是浏览器发起请求时，在该字段中带上上次请求时得到的last-modified信息。这样服务器端就可以进行比较，如果if-modified-since字段中的时间早于服务器端最近一次修改的时间，那么说明浏览器请求的资源有更新过，则需要重新返回资源，状态码标为200；相反地，如果服务器端last-modified的时间早于客户端发来的if-modified-since字段，那么就无需更新请求的资源，状态码标为304，浏览器可以继续使用缓存的资源。说起来可能比较绕，总结起来就是一切的目的都是为了判断请求的资源是否更新过，缓存是否还有效。

- etag / if-none-match

Etag是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）。if-none-match是客户端再次发起该请求时，携带上次请求返回的唯一标识etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有if-none-match，则会根据if-none-match的字段值与该资源在服务器的etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200。

综合上述情况，可以总结出协商缓存机制的流程图：

- 协商缓存生效 返回304

![](/img/304.png)

- 协商缓存失效 返回200 重新返回新内容 

![](/img/200.png)



## 4. 总结

强制缓存优于协商缓存来进行，如果强制缓存生效则使用强制缓存，如果强制缓存失效则进行协商缓存，通过判断相应字段的值来确定是否更新请求的结果。而在第一部分总结的浏览器的两条运行机制确保不会出现缓存被丢弃，或者无法找到缓存的情况。

