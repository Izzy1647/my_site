---
title: 接雨水
date: 2020-03-02 13:11:21
tags: [算法,JavaScript]
---

最近做leetcode碰到两道很有意思的题目，都和水有关。这一篇分享一下我关于接雨水这道题的一些思路和做法。这道题难度是困难，但是题干很简短，并且很有意思。

<!--more-->

## 1. 题目

来源：leetcode 42

![](/img/trap_prob.png)

## 2. 思路与解法

这道题难度是困难，但是题干很简短，并且很有意思。

### 2.1 按行计数

一种比较朴素的想法是按行计数：从第一行开始遇到柱子开始计数，直到遇到下一个柱子时停止，并且开始新的计数。如果直到结束都没有遇到新的柱子，就将当前计数清零。或者遍历每一层的每一个点，如果该点不是墙并且左右两边都有墙，则证明该点有水。这样做实在是太暴力了，会被判定超时，那么想想有没有别的办法。

### 2.2 按列计数

按列计数的想法简单来说就是依次看每一列能接多少水。显然，每一列的接水量等于该列左右最高的墙的较低的那个的高度减去这一列墙的高度，如果没有这一列墙的高度高的话就是0。说起来有点绕，下图解释的比较直观：第六列的墙高为0，它左边最高的墙高2，右边最高的墙高3，于是第六列接水量为2-0=0.



![trap1](/img/trap1.png)

有了想法，代码如下：

```javascript
var trap = function(height) {
    let len = height.length
    let sum = new Array(len)   // 存放每列水量
    
    for(let i=0;i<len;i++){
        let lheight = 0
        let rheight = 0
        for(let left=0;left<i;left++){   // 找左边最高的
            if(height[left]>lheight){
                lheight = height[left]
            }
        }
        for(let right=i;right<len;right++){  // 找右边最高的
            if(height[right]>rheight){
                rheight = height[right]
            }
        }
        let setHeight = rheight<lheight?rheight:lheight  // 找左右更低的
        sum[i] = setHeight>height[i]?setHeight-height[i]:0  // 这一列水量
    }
  
    let res = 0    //计算总和
    for(let i in sum){
        res+=sum[i]
    }
    return res
};
```

这样做得到的结果正确，也可以AC，但是不免觉得循环里面套循环，时间复杂度还是很高，达到O(n^2)的级别。注意到其实找左右最高这一步可以简化。

### 2.3 按列计数的优化

上面做法中，找左右最高的过程中进行了大量重复的工作。举个例子：第六列左边最高的墙高度是2，那么第七列左边最高的墙高度则可以直接根据第六列左边最高的墙高度和第六列本身墙的高度来决定。如果第六列的高度比它左边的最高高度还要高，那么第七列左边的最高高度则是第六列的高度；而相反的，如果第六列高度没有它左边的最高高度高，那么第七列左边最高的高度和第六列左边最高的高度相等。因为有重叠性，就可以使用动态规划的方法。用递推公式来描述如下：
$$
L(i) = max(L(i-1),H(i-1))
$$
其中，L(i)指第i列左边最高的高度；H(i)指第i列的墙高。

那么有了这个递推公式后，就可以根据这个公式来创建两个数组，分别存放第i列左边和右边的最高高度，相当于是填表的操作。然后可以根据这个表来找到左右最高的高度，而不用每次都往左右循环了。代码如下：

```javascript
var trap = function(height){
    let len = height.length
    let sum = new Array(len)   // 存放每列水量
    
    // 注意初始化成全0数组
    let leftHighest = new Array(len).fill(0)   // 存放第i个墙左边最高的高度 不含i  
    let rightHighest = new Array(len).fill(0)  // 存放第i个墙右边最高的高度 不含i

    for(let i=1;i<len-1;i++){   // 得到leftHighest数组
        leftHighest[i] = Math.max(leftHighest[i-1],height[i-1])       
    }
    for(let i=len-2;i>-1;i--){  // 得到rightHighest数组
        rightHighest[i] = Math.max(rightHighest[i+1],height[i+1])
    }

    for(let i=0;i<len;i++){
        let setHeight = leftHighest[i]<[rightHighest[i]]?leftHighest[i]:rightHighest[i]
        sum[i] = setHeight>height[i]?setHeight-height[i]:0
    }
    
    let res = 0
    for(let i in sum){
        res += sum[i]
    }
    return res
}
```

可以看出，时间复杂度从n平方的量级降到了n的量级。值得注意的是，初始化数组时要初始化为0。如果不赋值的话，初始值默认为undefined，最后数组的元素会全部变成NaN，也就是Not a Number。原因在于Math.max中传入undefined的话返回值为NaN：

```javascript
Math.max(undefined,0) // NaN
Math.max(NaN,0) // NaN
```

